const fs = require('fs/promises');
const path = require('path');
const { fileURLToPath } = require('url');


const TARGET_URL = 'https://netboxlabscms.kinsta.cloud/wp-json/together/options';
// Output directory relative to this script's parent directory, then into src/components/global
const OUTPUT_DIR = path.resolve(__dirname, '../src/components/global');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'options.data.ts');

// Default fallback options if fetch fails
const DEFAULT_OPTIONS = {
  "header": {
    "nav": {
      "items": [
        {
          "link": {
            "title": "Platform",
            "url": "/#",
            "target": ""
          },
          "has_submenu": false
        },
        {
          "link": {
            "title": "Solutions", 
            "url": "/solutions/",
            "target": ""
          },
          "has_submenu": false
        },
        {
          "link": {
            "title": "Resources",
            "url": "/#",
            "target": ""
          },
          "has_submenu": false
        }
      ]
    }
  }
};

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

async function fetchAndSaveOptions() {
  try {
    console.log(`Fetching options from ${TARGET_URL}...`);
    
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
    
    const response = await fetch(TARGET_URL, {
      signal: controller.signal,
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'NetBox Labs Documentation Builder'
      }
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} ${response.statusText}`);
    }
    
    const contentType = response.headers.get('content-type');
    const text = await response.text();
    
    // Handle WordPress responses that mix HTML notices with JSON
    let jsonData;
    if (contentType && contentType.includes('application/json')) {
      // Try to find JSON in the response (may have HTML prefix from WordPress notices)
      const jsonStart = text.indexOf('{');
      if (jsonStart === -1) {
        throw new Error(`No JSON found in response. Response: ${text.substring(0, 200)}...`);
      }
      
      const jsonPortion = text.substring(jsonStart);
      try {
        jsonData = JSON.parse(jsonPortion);
        if (jsonStart > 0) {
          console.log('‚ö†Ô∏è Note: WordPress notices detected in CMS response, but JSON was extracted successfully.');
        }
      } catch (parseError) {
        throw new Error(`Failed to parse JSON from response. Parse error: ${parseError.message}. JSON portion: ${jsonPortion.substring(0, 200)}...`);
      }
    } else {
      throw new Error(`Expected JSON but received ${contentType || 'unknown content type'}. Response: ${text.substring(0, 200)}...`);
    }
    
    const data = jsonData;
    console.log('‚úÖ Successfully fetched options data from CMS.');

    // Ensure the target directory exists
    await fs.mkdir(OUTPUT_DIR, { recursive: true });

    const fileContent = `// This file is auto-generated by scripts/fetchOptions.ts
// Do not edit this file manually.

/* eslint-disable */
// Disable ESLint for this auto-generated file to avoid issues with potentially complex data structures.

export const options = ${JSON.stringify(data, null, 2)} as const;
`;

    await fs.writeFile(OUTPUT_FILE, fileContent, 'utf-8');
    console.log(`Successfully saved options to ${OUTPUT_FILE}`);

  } catch (error) {
    console.warn('‚ö†Ô∏è Warning: CMS options fetch failed:', error.message);
    
    // Check if options file already exists
    const optionsFileExists = await fileExists(OUTPUT_FILE);
    
    if (optionsFileExists) {
      console.log('‚úÖ Using existing options.data.ts file as fallback');
      return; // Keep existing file, don't fail build
    }
    
    // Create fallback file if none exists
    console.log('üìù Creating fallback options.data.ts with default navigation structure');
    
    try {
      await fs.mkdir(OUTPUT_DIR, { recursive: true });
      
      const fallbackContent = `// This file is auto-generated by scripts/fetchOptions.ts
// Do not edit this file manually.
// NOTE: Using fallback data due to CMS fetch failure

/* eslint-disable */
// Disable ESLint for this auto-generated file to avoid issues with potentially complex data structures.

export const options = ${JSON.stringify(DEFAULT_OPTIONS, null, 2)} as const;
`;

      await fs.writeFile(OUTPUT_FILE, fallbackContent, 'utf-8');
      console.log(`‚úÖ Created fallback options file at ${OUTPUT_FILE}`);
      
    } catch (fallbackError) {
      console.error('‚ùå Failed to create fallback options file:', fallbackError);
      process.exit(1); // Only fail if we can't create any options file
    }
  }
}

fetchAndSaveOptions();